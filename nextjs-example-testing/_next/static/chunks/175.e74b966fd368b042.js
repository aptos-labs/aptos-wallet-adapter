"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[175,686],{5686:function(e,t,r){r.r(t),r.d(t,{SuiWormholeCore:function(){return s}});var i=r(52571),a=r(29632),n=r(34138),o=r(84537);class s{network;chain;provider;contracts;chainId;coreBridgePackageId;constructor(e,t,r,i){this.network=e,this.chain=t,this.provider=r,this.contracts=i,this.chainId=(0,a.Vn)(t);let n=i.coreBridge;if(!n)throw Error(`CoreBridge contract Address for chain ${t} not found`);this.coreBridgePackageId=n}getGuardianSet(e){throw Error("Method not implemented.")}getMessageFee(){throw Error("Method not implemented.")}static async fromRpc(e,t){let[r,i]=await n.$.chainFromRpc(e),a=t[i];if(a.network!==r)throw Error(`Network mismatch: ${a.network} !== ${r}`);return new s(r,i,e,a.contracts)}async *verifyMessage(e,t){throw Error("Method not implemented.")}async *publishMessage(e,t){throw Error("Method not implemented.")}async parseTransaction(e){return(await this.parseMessages(e)).map(e=>({emitter:e.emitterAddress,sequence:e.sequence,chain:this.chain}))}async getGuardianSetIndex(){throw Error("Method not implemented.")}async parseMessages(e){let t=await this.provider.getTransactionBlock({digest:e,options:{showEvents:!0,showEffects:!0,showInput:!0}}),r=t.events?.filter(e=>e.type.endsWith("WormholeMessage"));if(!r||0==r.length)throw Error("WormholeMessage not found");return r.map(e=>{let t=e.parsedJson;return(0,i.oN)("Uint8Array",{emitterChain:this.chain,emitterAddress:new o.Ne(t.sender).toUniversalAddress(),sequence:BigInt(t.sequence),guardianSet:0,timestamp:Number(t.timestamp),consistencyLevel:t.consistency_level,nonce:t.nonce,signatures:[],payload:new Uint8Array(t.payload)})})}}(0,i.sW)("Sui","WormholeCore",s)},53175:function(e,t,r){r.r(t),r.d(t,{SuiAutomaticTokenBridge:function(){return b},SuiTokenBridge:function(){return w},getTokenCoinType:function(){return m},getTokenFromTokenRegistry:function(){return p}});var i=r(52571),a=r(67986),n=r(11421),o=r(34499),s=r(34267),d=r(29632),c=r(49332),l=r(84537),g=r(34138),h=r(74533),u=r(36963),f=r(15899);let p=async(e,t,r)=>{if(!(0,l.QI)(r))throw Error(`Invalid Sui type: ${r}`);let i=await (0,u.dC)(e,t);if(!i)throw Error(`Unable to fetch object fields from token bridge state. Object ID: ${t}`);let a=i.token_registry.fields?.id?.id;if(!a)throw Error("Unable to fetch token registry object ID");let n=(0,l.VC)(i.token_registry?.type);if(!n)throw Error("Unable to fetch token registry package ID");return e.getDynamicFieldObject({parentId:a,name:{type:`${n}::token_registry::Key<${r}>`,value:{dummy_field:!1}}})},m=async(e,t,r,i)=>{let a=await (0,u.dC)(e,t);if(!a)throw Error("Unable to fetch object fields from token bridge state");let n=a.token_registry?.fields?.coin_types,o=n?.fields?.id?.id;if(!o)throw Error("Unable to fetch coin types");let s=(0,l.EK)(n?.type);if(!s)throw Error("Unable to get key type");let d=await e.getDynamicFieldObject({parentId:o,name:{type:s,value:{addr:[...r],chain:i}}});if(d.error){if("dynamicFieldNotFound"===d.error.code)return null;throw Error(`Unexpected getDynamicFieldObject response ${d.error}`)}let c=(0,h.Wm)(d);if(!c)return null;if(!(0,h.lP)(c))throw Error("What?");return"value"in c?(0,l.VL)(c.value):null};r(5686);class w{network;chain;provider;contracts;coreBridgeObjectId;tokenBridgeObjectId;chainId;constructor(e,t,r,i){this.network=e,this.chain=t,this.provider=r,this.contracts=i,this.chainId=s.X.get(e,t);let a=this.contracts.tokenBridge;if(!a)throw Error(`Wormhole Token Bridge contract for domain ${t} not found`);let n=this.contracts.coreBridge;if(!n)throw Error(`Wormhole Token Bridge contract for domain ${t} not found`);this.tokenBridgeObjectId=a,this.coreBridgeObjectId=n}static async fromRpc(e,t){let[r,i]=await g.$.chainFromRpc(e),a=t[i];if(a.network!==r)throw Error(`Network mismatch: ${a.network} != ${r}`);return new w(r,i,e,a.contracts)}async isWrappedAsset(e){try{return await this.getOriginalAsset(e),!0}catch{return!1}}async getOriginalAsset(e){let t=e.getCoinType();if(!(0,l.QI)(t))throw Error(`Invalid Sui type: ${t}`);let r=await p(this.provider,this.tokenBridgeObjectId,t),a=(0,h.Wm)(r);if(!a)throw(0,i.qE)(t);if(!(0,h.lP)(a))throw Error("Expected fields to be a MoveStruct");if(!("value"in a))throw Error("Expected a `value` key in fields of MoveStruct");let n=a.value;if(!(0,h.YV)(n))throw Error("Expected fields to be a MoveStruct");let o=(0,l.VL)(n.type);if(t=(0,l.VL)(t),o.includes(`wrapped_asset::WrappedAsset<${t}>`)){let e=n.fields.info;if(!(0,h.YV)(e))throw Error("Expected fields to be a MoveStruct");let t=e.fields.token_address;if(!(0,h.YV)(t))throw Error("Expected fields to be a MoveStruct");if(!(0,h.lP)(t.fields))throw Error("Expected address data to be a MoveObject");if(!("value"in t.fields))throw Error("Expected a `value` key in fields of MoveStruct");let r=t.fields.value;if(!(0,h.YV)(r))throw Error("Expected fields to be a MoveStruct");let a=new Uint8Array(r.fields.data);return{chain:(0,d.k5)(Number(e.fields.token_chain)),address:new i.Vf(a)}}throw(0,i.qE)(t)}async getTokenUniversalAddress(e){let t=e.getCoinType();if(!(0,l.QI)(t))throw Error(`Invalid Sui type: ${t}`);let r=await p(this.provider,this.tokenBridgeObjectId,t),a=(0,h.Wm)(r);if(!a)throw Error(`Token of type ${t} has not been registered with the token bridge. Has it been attested?`);if(!(0,h.lP)(a))throw Error("Expected fields to be a MoveStruct");if(!("value"in a))throw Error("Expected a `value` key in fields of MoveStruct");let n=a.value;if(!(0,h.YV)(n))throw Error("Expected fields to be a MoveStruct");let o=(0,l.VL)(n.type);if(t=(0,l.VL)(t),o.includes(`native_asset::NativeAsset<${t}>`)){let e=n.fields.token_address;if(!(0,h.YV)(e))throw Error("Expected fields to be a MoveStruct");if(!("value"in e.fields))throw Error("Expected a `value` key in fields of MoveStruct");let t=e.fields.value;if(!(0,h.YV)(t))throw Error("Expected fields to be a MoveStruct");let r=new Uint8Array(t.fields.data);return new i.Vf(r)}throw Error(`Token of type ${t} is not a native asset`)}async getTokenNativeAddress(e,t){let r=await m(this.provider,this.tokenBridgeObjectId,t.toUint8Array(),(0,d.Vn)(e));if(!r)throw Error(`Token ${t.toString()} not found in token registry`);return new l.Ne(r)}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch(e){}return!1}async getWrappedAsset(e){if((0,i.tY)(e.address))throw Error("Token Address required, 'native' literal not supported");let t=await m(this.provider,this.tokenBridgeObjectId,e.address.toUniversalAddress().toUint8Array(),(0,d.Vn)(e.chain));if(!t)throw(0,i.qE)((0,i.QC)(e));return(0,i.lR)(this.chain,t)}async isTransferCompleted(e){let t=await (0,u.dC)(this.provider,this.tokenBridgeObjectId);if(!t)throw Error("Unable to fetch object fields from token bridge state");let r=t.consumed_vaas?.fields?.hashes,a=(0,l.EK)(r?.fields?.items?.type);if(!a)throw Error("Unable to get key type");let n=r?.fields?.items?.fields?.id?.id;if(!n)throw Error("Unable to fetch consumed VAAs table");let o=await this.provider.getDynamicFieldObject({parentId:n,name:{type:a,value:{data:[...(0,i.Ev)(e.hash)]}}});if(!o.error)return!0;if("dynamicFieldNotFound"===o.error.code)return!1;throw Error(`Unexpected getDynamicFieldObject response ${o.error}`)}async *createAttestation(e){let t=e.toString(),r=await this.provider.getCoinMetadata({coinType:t});if(null===r||null===r.id)throw Error(`Coin metadata ID for type ${t} not found`);let[i,o]=await this.getPackageIds(),s=new a.a,[d]=s.splitCoins(s.gas,[s.pure(0n)]),[c]=s.moveCall({target:`${o}::attest_token::attest_token`,arguments:[s.object(this.tokenBridgeObjectId),s.object(r.id),s.pure(0n)],typeArguments:[t]});s.moveCall({target:`${i}::publish_message::publish_message`,arguments:[s.object(this.coreBridgeObjectId),d,c,s.object(n.H$)]}),yield this.createUnsignedTx(s,"Sui.TokenBridge.CreateAttestation")}async *submitAttestation(e,t){let[r,o]=await this.getPackageIds(),s=t.toString(),d=Math.min(e.payload.decimals,8),c=await this.getCoinBuildOutput(r,o,d),g=await (0,u.uH)(c,s);yield this.createUnsignedTx(g,"Sui.TokenBridge.PrepareCreateWrapped");let f="",p="",m="",w="",y="",b=!1;for(;!b;)for(let e of(await new Promise(e=>setTimeout(e,500)),(await this.provider.queryTransactionBlocks({filter:{FromAddress:s},options:{showObjectChanges:!0},limit:3})).data))if("objectChanges"in e){for(let t of e.objectChanges)(0,h.ER)(t)&&void 0!==t.packageId?f=t.packageId:(0,h.FH)(t)&&t.objectType.includes("WrappedAssetSetup")?(p=t.objectId,y=t.objectType.split(", ")[1].replace(">","")):(0,h.FH)(t)&&t.objectType.includes("UpgradeCap")?m=t.objectId:(0,h.FH)(t)&&t.objectType.includes("CoinMetadata")&&(w=t.objectId);if(""!==f&&""!==p&&""!==m&&""!==w){b=!0;break}f="",p="",m="",w=""}let k=(0,l.Qz)(f),v=new a.a,[j]=v.moveCall({target:`${r}::vaa::parse_and_verify`,arguments:[v.object(this.coreBridgeObjectId),v.pure((0,u.jd)((0,i.qC)(e))),v.object(n.H$)]}),[I]=v.moveCall({target:`${o}::vaa::verify_only_once`,arguments:[v.object(this.tokenBridgeObjectId),j]});v.moveCall({target:`${o}::create_wrapped::complete_registration`,arguments:[v.object(this.tokenBridgeObjectId),v.object(w),v.object(p),v.object(m),I],typeArguments:[k,y]}),yield this.createUnsignedTx(v,"Sui.TokenBridge.SubmitAttestation")}async *transfer(e,t,r,o,s){let c=e.toString(),l=((0,i.tY)(r)?n.uq:r).toString(),[f,...p]=(await g.$.getCoins(this.provider,e,l)).filter(e=>(0,h.Y4)(e.coinType,l));if(void 0===f)throw Error(`Coins array doesn't contain any coins of type ${l}`);let[m,w]=await this.getPackageIds(),y=new a.a,[b]=(()=>{if(l===n.uq)return y.splitCoins(y.gas,[y.pure(o)]);{let e=y.object(f.coinObjectId);return p.length&&y.mergeCoins(e,p.map(e=>y.object(e.coinObjectId))),y.splitCoins(e,[y.pure(o)])}})(),[k]=y.splitCoins(y.gas,[y.pure(0n)]),[v]=y.moveCall({target:`${w}::state::verified_asset`,arguments:[y.object(this.tokenBridgeObjectId)],typeArguments:[l]});if(s){if(!c)throw Error("senderAddress is required for transfer with payload");let e=!1,r=await (async()=>{let t=await (0,u.bH)(this.provider,m,c);if(null!==t)return y.object(t);{let[t]=y.moveCall({target:`${m}::emitter::new`,arguments:[y.object(this.coreBridgeObjectId)]});return e=!0,t}})(),[i,a]=y.moveCall({target:`${w}::transfer_tokens_with_payload::prepare_transfer`,arguments:[r,v,b,y.pure((0,d.Vn)(t.chain)),y.pure(t.address.toUint8Array()),y.pure([...s]),y.pure(0)],typeArguments:[l]});y.moveCall({target:`${w}::coin_utils::return_nonzero`,arguments:[a],typeArguments:[l]});let[o]=y.moveCall({target:`${w}::transfer_tokens_with_payload::transfer_tokens_with_payload`,arguments:[y.object(this.tokenBridgeObjectId),i],typeArguments:[l]});y.moveCall({target:`${m}::publish_message::publish_message`,arguments:[y.object(this.coreBridgeObjectId),k,o,y.object(n.H$)]}),e&&y.transferObjects([r],y.pure(c)),yield this.createUnsignedTx(y,"Sui.TokenBridge.TransferWithPayload")}else{let[e,r]=y.moveCall({target:`${w}::transfer_tokens::prepare_transfer`,arguments:[v,b,y.pure((0,d.Vn)(t.chain)),y.pure((0,u.jd)(t.address.toUint8Array())),y.pure(0n),y.pure(0)],typeArguments:[l]});y.moveCall({target:`${w}::coin_utils::return_nonzero`,arguments:[r],typeArguments:[l]});let[i]=y.moveCall({target:`${w}::transfer_tokens::transfer_tokens`,arguments:[y.object(this.tokenBridgeObjectId),e],typeArguments:[l]});y.moveCall({target:`${m}::publish_message::publish_message`,arguments:[y.object(this.coreBridgeObjectId),k,i,y.object(n.H$)]}),yield this.createUnsignedTx(y,"Sui.TokenBridge.Transfer")}}async *redeem(e,t,r=!0){let o=await m(this.provider,this.tokenBridgeObjectId,t.payload.token.address.toUint8Array(),(0,d.Vn)(t.payload.token.chain));if(!o)throw Error("Unable to fetch token coinType");let[s,c]=await this.getPackageIds(),l=new a.a,[g]=l.moveCall({target:`${s}::vaa::parse_and_verify`,arguments:[l.object(this.coreBridgeObjectId),l.pure((0,u.jd)((0,i.qC)(t))),l.object(n.H$)]}),[h]=l.moveCall({target:`${c}::vaa::verify_only_once`,arguments:[l.object(this.tokenBridgeObjectId),g]}),[f]=l.moveCall({target:`${c}::complete_transfer::authorize_transfer`,arguments:[l.object(this.tokenBridgeObjectId),h],typeArguments:[o]}),[p]=l.moveCall({target:`${c}::complete_transfer::redeem_relayer_payout`,arguments:[f],typeArguments:[o]});l.moveCall({target:`${c}::coin_utils::return_nonzero`,arguments:[p],typeArguments:[o]}),yield this.createUnsignedTx(l,"Sui.TokenBridge.Redeem")}async getWrappedNative(){return(0,i.lR)(this.chain,n.uq)}async getPackageIds(){return Promise.all([(0,u.$6)(this.provider,this.coreBridgeObjectId),(0,u.$6)(this.provider,this.tokenBridgeObjectId)])}async getCoinBuildOutput(e,t,r){if(r>8)throw Error("Decimals is capped at 8");let i=(await u.wI(this.provider,this.tokenBridgeObjectId))?.replace("0x","");if(!i)throw Error(`Original token bridge package ID not found for object ID ${this.tokenBridgeObjectId}`);let a="a11ceb0b060000000901000a020a14031e1704350405392d07669f01088502600ae502050cea02160004010b010c0205020d000002000201020003030c020001000104020700000700010001090801010c020a050600030803040202000302010702080007080100020800080303090002070801010b020209000901010608010105010b0202080008030209000504434f494e095478436f6e7465787408565f5f305f325f3011577261707065644173736574536574757004636f696e0e6372656174655f777261707065640b64756d6d795f6669656c6404696e697414707265706172655f726567697374726174696f6e0f7075626c69635f7472616e736665720673656e646572087472616e736665720a74785f636f6e746578740f76657273696f6e5f636f6e74726f6c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002"+i+"00020106010000000001090b0031"+r.toString(16).padStart(2,"0")+"0a0138000b012e110238010200";return{modules:[c.cn.encode(c.$v.decode(a))],dependencies:["0x1","0x2",t,e].map(e=>(0,o.Fw)(e))}}createUnsignedTx(e,t,r=!1){return new f.A(e,this.network,this.chain,t,r)}}var y=r(51327);class b{network;chain;connection;contracts;tokenBridgeRelayerObjectId;coreBridgeObjectId;tokenBridgeObjectId;fields;constructor(e,t,r,i){this.network=e,this.chain=t,this.connection=r,this.contracts=i;let{tokenBridge:a,tokenBridgeRelayer:n,coreBridge:o}=i;if(!a||!n||!o)throw Error(`Some object IDs for ${t} Automatic Token Bridge not found`);this.tokenBridgeRelayerObjectId=n,this.tokenBridgeObjectId=a,this.coreBridgeObjectId=o}static async fromRpc(e,t){let[r,i]=await g.$.chainFromRpc(e),a=t[i];if(a.network!==r)throw Error(`Network mismatch for chain ${i}: ${a.network} != ${r}`);return new b(r,i,e,a.contracts)}async *transfer(e,t,r,o,s){let h=new l.Ne((0,i.tY)(r)?g.$.nativeTokenId(this.network,this.chain).address:r).getCoinType(),{coreBridge:u,tokenBridge:f}=await this.getPackageIds(),p=new a.a,m=BigInt(0),[w]=p.splitCoins(p.gas,[p.pure(m)]),[y]=await (async()=>{if((0,i.tY)(r))return p.splitCoins(p.gas,[p.pure(o)]);{let[t,...r]=(await g.$.getCoins(this.connection,e,h)).filter(e=>e.coinType===h);if(void 0===t)throw Error(`Coins array doesn't contain any coins of type ${h}`);let i=p.object(t.coinObjectId);return r.length&&p.mergeCoins(i,r.map(e=>p.object(e.coinObjectId))),p.splitCoins(i,[p.pure(o)])}})(),[b]=p.moveCall({target:`${f}::state::verified_asset`,arguments:[p.object(this.tokenBridgeObjectId)],typeArguments:[h]}),k=await this.getPackageId(),[v]=p.moveCall({target:`${k}::transfer::transfer_tokens_with_relay`,arguments:[p.object(this.tokenBridgeRelayerObjectId),y,b,p.pure.u64(s??0n),p.pure.u16((0,d.Vn)(t.chain)),p.pure.address(c.$v.encode(t.address.toUint8Array(),!0)),p.pure.u32(123)],typeArguments:[h]}),[j]=p.moveCall({target:`${f}::transfer_tokens_with_payload::transfer_tokens_with_payload`,arguments:[p.object(this.tokenBridgeObjectId),v],typeArguments:[h]});p.moveCall({target:`${u}::publish_message::publish_message`,arguments:[p.object(this.coreBridgeObjectId),w,j,p.object(n.H$)]}),yield this.createUnsignedTx(p,"AutomaticTokenBridge.transfer")}async *redeem(e,t){let{coreBridge:r,tokenBridge:o}=await this.getPackageIds(),{address:s,chain:c}=t.payload.token,l=await m(this.connection,this.tokenBridgeObjectId,s.toUniversalAddress().toUint8Array(),(0,d.Vn)(c));if(!l)throw Error("Unable to fetch token coinType");let g=new a.a,[h]=g.moveCall({target:`${r}::vaa::parse_and_verify`,arguments:[g.object(this.coreBridgeObjectId),g.pure((0,u.jd)((0,i.qC)(t))),g.object(n.H$)]}),[f]=g.moveCall({target:`${o}::vaa::verify_only_once`,arguments:[g.object(this.tokenBridgeObjectId),h]}),[p]=g.moveCall({target:`${o}::complete_transfer_with_payload::authorize_transfer`,arguments:[g.object(this.tokenBridgeObjectId),f],typeArguments:[l]}),w=await this.getPackageId();g.moveCall({target:`${w}::redeem::complete_transfer`,arguments:[g.object(this.tokenBridgeRelayerObjectId),p],typeArguments:[l]}),yield this.createUnsignedTx(g,"AutomaticTokenBridge.redeem")}async getRelayerFee(e,t){let r=(0,i.tY)(t)?g.$.nativeTokenId(this.network,this.chain):t,a=await this.getTokenInfo(r.toString());if(null===a)throw Error("Unsupported token for relay");let n=await this.getFields(),o=await this.connection.getDynamicFieldObject({parentId:this.tokenBridgeRelayerObjectId,name:{type:"vector<u8>",value:Array.from(c.aI.encode("relayer_fees"))}});if(!o.data||!o.data.content){if(o.error)throw Error("Failed to get relayer fees: "+JSON.stringify(o.error));throw Error("Unable to compute relayer fee")}let{content:s}=o.data;if(!(0,h.YV)(s)||!(0,h.D7)(s.fields.id))throw Error("Unable to compute relayer fee");let l=await this.connection.getDynamicFieldObject({parentId:s.fields.id.id,name:{type:"u16",value:(0,d.Vn)(e)}});if(!l.data||!l.data.content){if(l.error)throw Error("Failed to get relayer fees: "+JSON.stringify(o.error));throw Error("Unable to compute relayer fee")}let{content:u}=l.data;if(!(0,h.YV)(u))throw Error("Unable to compute relayer fee");let f=await g.$.getDecimals(this.chain,this.connection,t.toString()),p=a.swap_rate,m=n.relayer_fee_precision,w=n.swap_rate_precision,y=u.fields.value;return 10n**BigInt(f)*BigInt(y)*BigInt(w)/(BigInt(p)*BigInt(m))}async maxSwapAmount(e){let t=((0,i.tY)(e)?g.$.nativeTokenId(this.network,this.chain):e).toString(),r=await this.connection.getCoinMetadata({coinType:t});if(!r)throw Error("metadata is null");let n=await this.getPackageId(),o=new a.a;o.moveCall({target:`${n}::redeem::calculate_max_swap_amount_in`,arguments:[o.object(this.tokenBridgeRelayerObjectId),o.pure(r.decimals)],typeArguments:[t]});let s=await this.connection.devInspectTransactionBlock({transactionBlock:o,sender:c.$v.encode(new Uint8Array(32))});if(!s.results||0==s.results.length||!s.results[0]?.returnValues||s.results[0]?.returnValues.length!==1)throw Error("swap rate not set");return c.Al.decode(new Uint8Array(s.results[0].returnValues[0][0].toReversed()))}async nativeTokenAmount(e,t){let r=((0,i.tY)(e)?g.$.nativeTokenId(this.network,this.chain):e).toString(),n=await this.connection.getCoinMetadata({coinType:r});if(!n)throw Error("metadata is null");let o=await this.getPackageId(),s=new a.a;s.moveCall({target:`${o}::redeem::calculate_native_swap_amount_out`,arguments:[s.object(this.tokenBridgeRelayerObjectId),s.pure(t),s.pure(n.decimals)],typeArguments:[r]});let d=await this.connection.devInspectTransactionBlock({transactionBlock:s,sender:c.$v.encode(new Uint8Array(32))});if(!d.results||0==d.results.length||!d.results[0]?.returnValues||d.results[0]?.returnValues.length!==1)throw Error("swap rate not set");return c.Al.decode(new Uint8Array(d.results[0].returnValues[0][0].toReversed()))}async getRegisteredTokens(){let e=(await this.getFields()).registered_tokens.fields.id.id;return(await this.connection.getDynamicFields({parentId:e})).data.map(e=>{let{address:t,module:r,name:i}=(0,o.$A)(e.objectType).typeParams[0];return new l.Ne([t,r,i].join(y.M))})}async isRegisteredToken(e){let t=new l.Ne((0,i.tY)(e)?g.$.nativeTokenId(this.network,this.chain).address:e).unwrap();try{return await this.getTokenInfo(t)!==null}catch(e){console.error(e)}return!1}async getTokenInfo(e){let t=await this.getFields(),r=new l.Ne(t.registered_tokens.type).getPackageId(),i=t.registered_tokens.fields.id.id,a=new l.Ne(e),n=(0,h.Y4)(y.Z,a.unwrap())?y.Z:a.getCoinType();try{let e=await this.connection.getDynamicFieldObject({parentId:i,name:{type:`${r}::registered_tokens::Key<${n}>`,value:{dummy_field:!1}}});if(e.error)throw Error("Failed to get token info: "+JSON.stringify(e.error));if(!e.data||!e.data.content)throw Error("Failed to get token info: "+JSON.stringify(e));let{content:t}=e.data;if((0,h.YV)(t)&&(0,h.YV)(t.fields.value))return t.fields.value.fields;return null}catch(e){if(e?.code===-32e3&&e.message?.includes("RPC Error"))return console.error(e),null;throw e}}async getFields(){if(!this.fields){let e=await (0,u.dC)(this.connection,this.tokenBridgeRelayerObjectId);if(null===e)throw Error("Failed to get fields from token bridge relayer state");this.fields=e}return this.fields}async getPackageId(){let e=await this.getFields();return new l.Ne(e.registered_tokens.type).getPackageId()}async getPackageIds(){let[e,t]=await Promise.all([(0,u.$6)(this.connection,this.coreBridgeObjectId),(0,u.$6)(this.connection,this.tokenBridgeObjectId)]);return{coreBridge:e,tokenBridge:t}}createUnsignedTx(e,t,r=!1){return new f.A(e,this.network,this.chain,t,r)}}(0,i.sW)("Sui","TokenBridge",w),(0,i.sW)("Sui","AutomaticTokenBridge",b)},15899:function(e,t,r){r.d(t,{A:function(){return i}});class i{transaction;network;chain;description;parallelizable;constructor(e,t,r,i,a=!1){this.transaction=e,this.network=t,this.chain=r,this.description=i,this.parallelizable=a}}}}]);