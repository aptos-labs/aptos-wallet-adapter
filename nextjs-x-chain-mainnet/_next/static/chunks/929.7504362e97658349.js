"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[929],{54869:function(e,t,s){s.r(t),s.d(t,{AptosTokenBridge:function(){return A}});var n=s(79456),r=s(17255),a=s(85570),i=s(80033),o=s(96307),d=s(34750),c=s(57735),h=s(24111),u=s(87141);let l=[{name:"tokenBridgeAddress",...n.N3.universalAddressItem},{name:"chain",...n.N3.chainItem()},{name:"domainSeparator",binary:"bytes",custom:a.aI.encode(o.C),omit:!0},{name:"tokenId",...n.N3.universalAddressItem},{name:"domainSeparator",binary:"bytes",custom:new Uint8Array([255]),omit:!0}],g=e=>(0,u.qC)(l,e);var y=s(86388),p=s(67094).Buffer;class A{network;chain;connection;contracts;chainId;tokenBridgeAddress;constructor(e,t,s,n){this.network=e,this.chain=t,this.connection=s,this.contracts=n,this.chainId=(0,r.Vn)(t);let a=n.tokenBridge;if(!a)throw Error(`TokenBridge contract Address for chain ${t} not found`);this.tokenBridgeAddress=a}static async fromRpc(e,t){let[s,n]=await i.O.chainFromRpc(e),r=t[n];if(r.network!==s)throw Error("Network mismatch "+r.network+" !== "+s);return new A(s,n,e,r.contracts)}async isWrappedAsset(e){try{return await this.getOriginalAsset(e),!0}catch(e){return!1}}async getOriginalAsset(e){let t=e.toString().split(o.C),s=null;try{s=await this.connection.getAccountResource({accountAddress:t[0],resourceType:`${this.tokenBridgeAddress}::state::OriginInfo`})}catch(t){if(t instanceof y.JR&&t.data?.error_code==="resource_not_found")throw(0,n.qE)(e.toString());throw t}if(!s)throw(0,n.qE)(e.toString());return{chain:(0,r.k5)(parseInt(s.token_chain.number)),address:new n.Vf(s.token_address.external_address)}}async getTokenUniversalAddress(e){return new n.Vf(a.$v.encode((0,n.DZ)(e.toString()),!0))}async getTokenNativeAddress(e,t){let s=e===this.chain?await this.getTypeFromExternalAddress(t.toString()):await this.getAssetFullyQualifiedType({chain:e,address:t});if(!s)throw Error("Invalid asset address.");return new d.fy(s)}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch(e){}return!1}async getWrappedAsset(e){if((0,n.tY)(e.address))throw Error("native asset cannot be a wrapped asset");let t=await this.getAssetFullyQualifiedType(e);if(!t)throw Error("Invalid asset address.");return await this.connection.getAccountResource({accountAddress:(0,c.FJ)(t),resourceType:`${this.tokenBridgeAddress}::state::OriginInfo`}),(0,n.lR)(this.chain,t)}async isTransferCompleted(e){let t=(await this.connection.getAccountResource({accountAddress:this.tokenBridgeAddress,resourceType:`${this.tokenBridgeAddress}::state::State`})).consumed_vaas.elems.handle;try{return await this.connection.getTableItem({handle:t,data:{key_type:"vector<u8>",value_type:"u8",key:`0x${p.from((0,n.Ev)(e.hash)).toString("hex")}`}}),!0}catch{return!1}}async getWrappedNative(){return(0,n.lR)(this.chain,o.E)}async *createAttestation(e,t){let s={chain:this.chain,address:new d.fy(e)},n=await this.getAssetFullyQualifiedType(s);if(!n)throw Error("Invalid asset address.");yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::attest_token::attest_token_entry`,typeArguments:[n],functionArguments:[]},"Aptos.AttestToken")}async *submitAttestation(e,t){yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::wrapped::create_wrapped_coin_type`,typeArguments:[],functionArguments:[(0,n.qC)(e)]},"Aptos.CreateWrappedCoinType");let s=await this.getAssetFullyQualifiedType(e.payload.token);if(!s)throw Error("Invalid asset address.");yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::wrapped::create_wrapped_coin`,typeArguments:[s],functionArguments:[(0,n.qC)(e)]},"Aptos.CreateWrappedCoin")}async *transfer(e,t,s,a,i){let d=(0,n.tY)(s)?o.E:s.toString(),c=t.address.toUniversalAddress().toUint8Array(),h=(0,r.Vn)(t.chain);i?yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::transfer_tokens::transfer_tokens_with_payload_entry`,typeArguments:[d],functionArguments:[a,h,c,0n,i]},"Aptos.TransferTokensWithPayload"):yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::transfer_tokens::transfer_tokens_entry`,typeArguments:[d],functionArguments:[a,h,c,0n,0n]},"Aptos.TransferTokens")}async *redeem(e,t,s=!0){let r=t.payload.token.chain===this.chain?await this.getTypeFromExternalAddress(t.payload.token.address.toString()):await this.getAssetFullyQualifiedType(t.payload.token);if(!r)throw Error("Invalid asset address.");yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::complete_transfer::submit_vaa_and_register_entry`,typeArguments:[r],functionArguments:[(0,n.qC)(t)]},"Aptos.CompleteTransfer")}async getAssetFullyQualifiedType(e){if(e.chain===this.chain)return(0,c.nq)(e.address.toString())?e.address.toString():null;let t=A.getForeignAssetAddress(this.chain,this.tokenBridgeAddress,e);return`${t}::coin::T`}async getTypeFromExternalAddress(e){try{let{handle:t}=(await this.connection.getAccountResource({accountAddress:this.tokenBridgeAddress,resourceType:`${this.tokenBridgeAddress}::state::State`})).native_infos,s=await this.connection.getTableItem({handle:t,data:{key_type:`${this.tokenBridgeAddress}::token_hash::TokenHash`,value_type:"0x1::type_info::TypeInfo",key:{hash:e}}});return s?[s.account_address,String.fromCharCode(...a.$v.decode(s.module_name)),String.fromCharCode(...a.$v.decode(s.struct_name))].join(o.C):null}catch{return null}}static getForeignAssetAddress(e,t,s){if((0,n.tY)(s.address))throw Error("Invalid token address");let r=g({chain:s.chain,tokenBridgeAddress:new d.fy(t).toUniversalAddress(),tokenId:s.address.toUniversalAddress()});return a.$v.encode((0,n.DZ)(r),!0)}createUnsignedTx(e,t,s=!1){return new h.N(e,this.network,this.chain,t,s)}}(0,n.sW)("Aptos","TokenBridge",A)},24111:function(e,t,s){s.d(t,{N:function(){return n}});class n{transaction;network;chain;description;parallelizable;constructor(e,t,s,n,r=!1){this.transaction=e,this.network=t,this.chain=s,this.description=n,this.parallelizable=r}}}}]);