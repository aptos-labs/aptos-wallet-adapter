"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[623,536],{19536:function(e,t,r){r.r(t),r.d(t,{SuiWormholeCore:function(){return s}});var i=r(79456),n=r(17255),a=r(61049),o=r(85922);class s{network;chain;provider;contracts;chainId;coreBridgePackageId;constructor(e,t,r,i){this.network=e,this.chain=t,this.provider=r,this.contracts=i,this.chainId=(0,n.Vn)(t);let a=i.coreBridge;if(!a)throw Error(`CoreBridge contract Address for chain ${t} not found`);this.coreBridgePackageId=a}getGuardianSet(e){throw Error("Method not implemented.")}getMessageFee(){throw Error("Method not implemented.")}static async fromRpc(e,t){let[r,i]=await a.$.chainFromRpc(e),n=t[i];if(n.network!==r)throw Error(`Network mismatch: ${n.network} !== ${r}`);return new s(r,i,e,n.contracts)}async *verifyMessage(e,t){throw Error("Method not implemented.")}async *publishMessage(e,t){throw Error("Method not implemented.")}async parseTransaction(e){return(await this.parseMessages(e)).map(e=>({emitter:e.emitterAddress,sequence:e.sequence,chain:this.chain}))}async getGuardianSetIndex(){throw Error("Method not implemented.")}async parseMessages(e){let t=await this.provider.getTransactionBlock({digest:e,options:{showEvents:!0,showEffects:!0,showInput:!0}}),r=t.events?.filter(e=>e.type.endsWith("WormholeMessage"));if(!r||0==r.length)throw Error("WormholeMessage not found");return r.map(e=>{let t=e.parsedJson;return(0,i.oN)("Uint8Array",{emitterChain:this.chain,emitterAddress:new o.Ne(t.sender).toUniversalAddress(),sequence:BigInt(t.sequence),guardianSet:0,timestamp:Number(t.timestamp),consistencyLevel:t.consistency_level,nonce:t.nonce,signatures:[],payload:new Uint8Array(t.payload)})})}}(0,i.sW)("Sui","WormholeCore",s)},9623:function(e,t,r){r.r(t),r.d(t,{SuiAutomaticTokenBridge:function(){return b},SuiTokenBridge:function(){return w},getTokenCoinType:function(){return m},getTokenFromTokenRegistry:function(){return p}});var i=r(79456),n=r(95351),a=r(4622),o=r(42732),s=r(64303),d=r(17255),c=r(85570),l=r(85922),u=r(61049),g=r(89970),h=r(45542),f=r(38313);let p=async(e,t,r)=>{if(!(0,l.QI)(r))throw Error(`Invalid Sui type: ${r}`);let i=await (0,h.dC)(e,t);if(!i)throw Error(`Unable to fetch object fields from token bridge state. Object ID: ${t}`);let n=i.token_registry.fields?.id?.id;if(!n)throw Error("Unable to fetch token registry object ID");let a=(0,l.VC)(i.token_registry?.type);if(!a)throw Error("Unable to fetch token registry package ID");return e.getDynamicFieldObject({parentId:n,name:{type:`${a}::token_registry::Key<${r}>`,value:{dummy_field:!1}}})},m=async(e,t,r,i)=>{let n=await (0,h.dC)(e,t);if(!n)throw Error("Unable to fetch object fields from token bridge state");let a=n.token_registry?.fields?.coin_types,o=a?.fields?.id?.id;if(!o)throw Error("Unable to fetch coin types");let s=(0,l.EK)(a?.type);if(!s)throw Error("Unable to get key type");let d=await e.getDynamicFieldObject({parentId:o,name:{type:s,value:{addr:[...r],chain:i}}});if(d.error){if("dynamicFieldNotFound"===d.error.code)return null;throw Error(`Unexpected getDynamicFieldObject response ${d.error}`)}let c=(0,g.Wm)(d);if(!c)return null;if(!(0,g.lP)(c))throw Error("What?");return"value"in c?(0,l.VL)(c.value):null};r(19536);class w{network;chain;provider;contracts;coreBridgeObjectId;tokenBridgeObjectId;chainId;constructor(e,t,r,i){this.network=e,this.chain=t,this.provider=r,this.contracts=i,this.chainId=s.X.get(e,t);let n=this.contracts.tokenBridge;if(!n)throw Error(`Wormhole Token Bridge contract for domain ${t} not found`);let a=this.contracts.coreBridge;if(!a)throw Error(`Wormhole Token Bridge contract for domain ${t} not found`);this.tokenBridgeObjectId=n,this.coreBridgeObjectId=a}static async fromRpc(e,t){let[r,i]=await u.$.chainFromRpc(e),n=t[i];if(n.network!==r)throw Error(`Network mismatch: ${n.network} != ${r}`);return new w(r,i,e,n.contracts)}async isWrappedAsset(e){try{return await this.getOriginalAsset(e),!0}catch{return!1}}async getOriginalAsset(e){let t=e.getCoinType();if(!(0,l.QI)(t))throw Error(`Invalid Sui type: ${t}`);let r=await p(this.provider,this.tokenBridgeObjectId,t),n=(0,g.Wm)(r);if(!n)throw(0,i.qE)(t);if(!(0,g.lP)(n))throw Error("Expected fields to be a MoveStruct");if(!("value"in n))throw Error("Expected a `value` key in fields of MoveStruct");let a=n.value;if(!(0,g.YV)(a))throw Error("Expected fields to be a MoveStruct");let o=(0,l.VL)(a.type);if(t=(0,l.VL)(t),o.includes(`wrapped_asset::WrappedAsset<${t}>`)){let e=a.fields.info;if(!(0,g.YV)(e))throw Error("Expected fields to be a MoveStruct");let t=e.fields.token_address;if(!(0,g.YV)(t))throw Error("Expected fields to be a MoveStruct");if(!(0,g.lP)(t.fields))throw Error("Expected address data to be a MoveObject");if(!("value"in t.fields))throw Error("Expected a `value` key in fields of MoveStruct");let r=t.fields.value;if(!(0,g.YV)(r))throw Error("Expected fields to be a MoveStruct");let n=new Uint8Array(r.fields.data);return{chain:(0,d.k5)(Number(e.fields.token_chain)),address:new i.Vf(n)}}throw(0,i.qE)(t)}async getTokenUniversalAddress(e){let t=e.getCoinType();if(!(0,l.QI)(t))throw Error(`Invalid Sui type: ${t}`);let r=await p(this.provider,this.tokenBridgeObjectId,t),n=(0,g.Wm)(r);if(!n)throw Error(`Token of type ${t} has not been registered with the token bridge. Has it been attested?`);if(!(0,g.lP)(n))throw Error("Expected fields to be a MoveStruct");if(!("value"in n))throw Error("Expected a `value` key in fields of MoveStruct");let a=n.value;if(!(0,g.YV)(a))throw Error("Expected fields to be a MoveStruct");let o=(0,l.VL)(a.type);if(t=(0,l.VL)(t),o.includes(`native_asset::NativeAsset<${t}>`)){let e=a.fields.token_address;if(!(0,g.YV)(e))throw Error("Expected fields to be a MoveStruct");if(!("value"in e.fields))throw Error("Expected a `value` key in fields of MoveStruct");let t=e.fields.value;if(!(0,g.YV)(t))throw Error("Expected fields to be a MoveStruct");let r=new Uint8Array(t.fields.data);return new i.Vf(r)}throw Error(`Token of type ${t} is not a native asset`)}async getTokenNativeAddress(e,t){let r=await m(this.provider,this.tokenBridgeObjectId,t.toUint8Array(),(0,d.Vn)(e));if(!r)throw Error(`Token ${t.toString()} not found in token registry`);return new l.Ne(r)}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch(e){}return!1}async getWrappedAsset(e){if((0,i.tY)(e.address))throw Error("Token Address required, 'native' literal not supported");let t=await m(this.provider,this.tokenBridgeObjectId,e.address.toUniversalAddress().toUint8Array(),(0,d.Vn)(e.chain));if(!t)throw(0,i.qE)((0,i.QC)(e));return(0,i.lR)(this.chain,t)}async isTransferCompleted(e){let t=await (0,h.dC)(this.provider,this.tokenBridgeObjectId);if(!t)throw Error("Unable to fetch object fields from token bridge state");let r=t.consumed_vaas?.fields?.hashes,n=(0,l.EK)(r?.fields?.items?.type);if(!n)throw Error("Unable to get key type");let a=r?.fields?.items?.fields?.id?.id;if(!a)throw Error("Unable to fetch consumed VAAs table");let o=await this.provider.getDynamicFieldObject({parentId:a,name:{type:n,value:{data:[...(0,i.Ev)(e.hash)]}}});if(!o.error)return!0;if("dynamicFieldNotFound"===o.error.code)return!1;throw Error(`Unexpected getDynamicFieldObject response ${o.error}`)}async *createAttestation(e){let t=e.toString(),r=await this.provider.getCoinMetadata({coinType:t});if(null===r||null===r.id)throw Error(`Coin metadata ID for type ${t} not found`);let[i,o]=await this.getPackageIds(),s=new n.Y,[d]=s.splitCoins(s.gas,[s.pure.u64(0n)]),[c]=s.moveCall({target:`${o}::attest_token::attest_token`,arguments:[s.object(this.tokenBridgeObjectId),s.object(r.id),s.pure.u32(0)],typeArguments:[t]});s.moveCall({target:`${i}::publish_message::publish_message`,arguments:[s.object(this.coreBridgeObjectId),d,c,s.object(a.H$)]}),yield this.createUnsignedTx(s,"Sui.TokenBridge.CreateAttestation")}async *submitAttestation(e,t){let[r,o]=await this.getPackageIds(),s=t.toString(),d=Math.min(e.payload.decimals,8),c=await this.getCoinBuildOutput(r,o,d),u=await (0,h.uH)(c,s);yield this.createUnsignedTx(u,"Sui.TokenBridge.PrepareCreateWrapped");let f="",p="",m="",w="",y="",b=!1;for(;!b;)for(let e of(await new Promise(e=>setTimeout(e,500)),(await this.provider.queryTransactionBlocks({filter:{FromAddress:s},options:{showObjectChanges:!0},limit:3})).data))if("objectChanges"in e){for(let t of e.objectChanges)(0,g.ER)(t)&&void 0!==t.packageId?f=t.packageId:(0,g.FH)(t)&&t.objectType.includes("WrappedAssetSetup")?(p=t.objectId,y=t.objectType.split(", ")[1].replace(">","")):(0,g.FH)(t)&&t.objectType.includes("UpgradeCap")?m=t.objectId:(0,g.FH)(t)&&t.objectType.includes("CoinMetadata")&&(w=t.objectId);if(""!==f&&""!==p&&""!==m&&""!==w){b=!0;break}f="",p="",m="",w=""}let k=(0,l.Qz)(f),v=new n.Y,[j]=v.moveCall({target:`${r}::vaa::parse_and_verify`,arguments:[v.object(this.coreBridgeObjectId),v.pure.vector("u8",(0,i.qC)(e)),v.object(a.H$)]}),[I]=v.moveCall({target:`${o}::vaa::verify_only_once`,arguments:[v.object(this.tokenBridgeObjectId),j]});v.moveCall({target:`${o}::create_wrapped::complete_registration`,arguments:[v.object(this.tokenBridgeObjectId),v.object(w),v.object(p),v.object(m),I],typeArguments:[k,y]}),yield this.createUnsignedTx(v,"Sui.TokenBridge.SubmitAttestation")}async *transfer(e,t,r,o,s){let c=e.toString(),l=((0,i.tY)(r)?a.uq:r).toString(),[f,...p]=(await u.$.getCoins(this.provider,e,l)).filter(e=>(0,g.Y4)(e.coinType,l));if(void 0===f)throw Error(`Coins array doesn't contain any coins of type ${l}`);let[m,w]=await this.getPackageIds(),y=new n.Y,[b]=(()=>{if(l===a.uq)return y.splitCoins(y.gas,[y.pure.u64(o)]);{let e=y.object(f.coinObjectId);return p.length&&y.mergeCoins(e,p.map(e=>y.object(e.coinObjectId))),y.splitCoins(e,[y.pure.u64(o)])}})(),[k]=y.splitCoins(y.gas,[y.pure.u64(0n)]),[v]=y.moveCall({target:`${w}::state::verified_asset`,arguments:[y.object(this.tokenBridgeObjectId)],typeArguments:[l]});if(s){if(!c)throw Error("senderAddress is required for transfer with payload");let e=!1,r=await (async()=>{let t=await (0,h.bH)(this.provider,m,c);if(null!==t)return y.object(t);{let[t]=y.moveCall({target:`${m}::emitter::new`,arguments:[y.object(this.coreBridgeObjectId)]});return e=!0,t}})(),[i,n]=y.moveCall({target:`${w}::transfer_tokens_with_payload::prepare_transfer`,arguments:[r,v,b,y.pure.u16((0,d.Vn)(t.chain)),y.pure.vector("u8",t.address.toUint8Array()),y.pure.vector("u8",s),y.pure.u32(0)],typeArguments:[l]});y.moveCall({target:`${w}::coin_utils::return_nonzero`,arguments:[n],typeArguments:[l]});let[o]=y.moveCall({target:`${w}::transfer_tokens_with_payload::transfer_tokens_with_payload`,arguments:[y.object(this.tokenBridgeObjectId),i],typeArguments:[l]});y.moveCall({target:`${m}::publish_message::publish_message`,arguments:[y.object(this.coreBridgeObjectId),k,o,y.object(a.H$)]}),e&&y.transferObjects([r],y.pure.address(c)),yield this.createUnsignedTx(y,"Sui.TokenBridge.TransferWithPayload")}else{let[e,r]=y.moveCall({target:`${w}::transfer_tokens::prepare_transfer`,arguments:[v,b,y.pure.u16((0,d.Vn)(t.chain)),y.pure.vector("u8",t.address.toUint8Array()),y.pure.u64(0n),y.pure.u32(0)],typeArguments:[l]});y.moveCall({target:`${w}::coin_utils::return_nonzero`,arguments:[r],typeArguments:[l]});let[i]=y.moveCall({target:`${w}::transfer_tokens::transfer_tokens`,arguments:[y.object(this.tokenBridgeObjectId),e],typeArguments:[l]});y.moveCall({target:`${m}::publish_message::publish_message`,arguments:[y.object(this.coreBridgeObjectId),k,i,y.object(a.H$)]}),yield this.createUnsignedTx(y,"Sui.TokenBridge.Transfer")}}async *redeem(e,t,r=!0){let o=await m(this.provider,this.tokenBridgeObjectId,t.payload.token.address.toUint8Array(),(0,d.Vn)(t.payload.token.chain));if(!o)throw Error("Unable to fetch token coinType");let[s,c]=await this.getPackageIds(),l=new n.Y,[u]=l.moveCall({target:`${s}::vaa::parse_and_verify`,arguments:[l.object(this.coreBridgeObjectId),l.pure.vector("u8",(0,i.qC)(t)),l.object(a.H$)]}),[g]=l.moveCall({target:`${c}::vaa::verify_only_once`,arguments:[l.object(this.tokenBridgeObjectId),u]}),[h]=l.moveCall({target:`${c}::complete_transfer::authorize_transfer`,arguments:[l.object(this.tokenBridgeObjectId),g],typeArguments:[o]}),[f]=l.moveCall({target:`${c}::complete_transfer::redeem_relayer_payout`,arguments:[h],typeArguments:[o]});l.moveCall({target:`${c}::coin_utils::return_nonzero`,arguments:[f],typeArguments:[o]}),yield this.createUnsignedTx(l,"Sui.TokenBridge.Redeem")}async getWrappedNative(){return(0,i.lR)(this.chain,a.uq)}async getPackageIds(){return Promise.all([(0,h.$6)(this.provider,this.coreBridgeObjectId),(0,h.$6)(this.provider,this.tokenBridgeObjectId)])}async getCoinBuildOutput(e,t,r){if(r>8)throw Error("Decimals is capped at 8");let i=(await h.wI(this.provider,this.tokenBridgeObjectId))?.replace("0x","");if(!i)throw Error(`Original token bridge package ID not found for object ID ${this.tokenBridgeObjectId}`);let n="a11ceb0b060000000901000a020a14031e1704350405392d07669f01088502600ae502050cea02160004010b010c0205020d000002000201020003030c020001000104020700000700010001090801010c020a050600030803040202000302010702080007080100020800080303090002070801010b020209000901010608010105010b0202080008030209000504434f494e095478436f6e7465787408565f5f305f325f3011577261707065644173736574536574757004636f696e0e6372656174655f777261707065640b64756d6d795f6669656c6404696e697414707265706172655f726567697374726174696f6e0f7075626c69635f7472616e736665720673656e646572087472616e736665720a74785f636f6e746578740f76657273696f6e5f636f6e74726f6c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002"+i+"00020106010000000001090b0031"+r.toString(16).padStart(2,"0")+"0a0138000b012e110238010200";return{modules:[c.cn.encode(c.$v.decode(n))],dependencies:["0x1","0x2",t,e].map(e=>(0,o.Fw)(e))}}createUnsignedTx(e,t,r=!1){return new f.A(e,this.network,this.chain,t,r)}}var y=r(56928);class b{network;chain;connection;contracts;tokenBridgeRelayerObjectId;coreBridgeObjectId;tokenBridgeObjectId;fields;constructor(e,t,r,i){this.network=e,this.chain=t,this.connection=r,this.contracts=i;let{tokenBridge:n,tokenBridgeRelayer:a,coreBridge:o}=i;if(!n||!a||!o)throw Error(`Some object IDs for ${t} Automatic Token Bridge not found`);this.tokenBridgeRelayerObjectId=a,this.tokenBridgeObjectId=n,this.coreBridgeObjectId=o}static async fromRpc(e,t){let[r,i]=await u.$.chainFromRpc(e),n=t[i];if(n.network!==r)throw Error(`Network mismatch for chain ${i}: ${n.network} != ${r}`);return new b(r,i,e,n.contracts)}async *transfer(e,t,r,o,s){let g=new l.Ne((0,i.tY)(r)?u.$.nativeTokenId(this.network,this.chain).address:r).getCoinType(),{coreBridge:h,tokenBridge:f}=await this.getPackageIds(),p=new n.Y,m=BigInt(0),[w]=p.splitCoins(p.gas,[p.pure.u64(m)]),[y]=await (async()=>{if((0,i.tY)(r))return p.splitCoins(p.gas,[p.pure.u64(o)]);{let[t,...r]=(await u.$.getCoins(this.connection,e,g)).filter(e=>e.coinType===g);if(void 0===t)throw Error(`Coins array doesn't contain any coins of type ${g}`);let i=p.object(t.coinObjectId);return r.length&&p.mergeCoins(i,r.map(e=>p.object(e.coinObjectId))),p.splitCoins(i,[p.pure.u64(o)])}})(),[b]=p.moveCall({target:`${f}::state::verified_asset`,arguments:[p.object(this.tokenBridgeObjectId)],typeArguments:[g]}),k=await this.getPackageId(),[v]=p.moveCall({target:`${k}::transfer::transfer_tokens_with_relay`,arguments:[p.object(this.tokenBridgeRelayerObjectId),y,b,p.pure.u64(s??0n),p.pure.u16((0,d.Vn)(t.chain)),p.pure.address(c.$v.encode(t.address.toUint8Array(),!0)),p.pure.u32(123)],typeArguments:[g]}),[j]=p.moveCall({target:`${f}::transfer_tokens_with_payload::transfer_tokens_with_payload`,arguments:[p.object(this.tokenBridgeObjectId),v],typeArguments:[g]});p.moveCall({target:`${h}::publish_message::publish_message`,arguments:[p.object(this.coreBridgeObjectId),w,j,p.object(a.H$)]}),yield this.createUnsignedTx(p,"AutomaticTokenBridge.transfer")}async *redeem(e,t){let{coreBridge:r,tokenBridge:o}=await this.getPackageIds(),{address:s,chain:c}=t.payload.token,l=await m(this.connection,this.tokenBridgeObjectId,s.toUniversalAddress().toUint8Array(),(0,d.Vn)(c));if(!l)throw Error("Unable to fetch token coinType");let u=new n.Y,[g]=u.moveCall({target:`${r}::vaa::parse_and_verify`,arguments:[u.object(this.coreBridgeObjectId),u.pure.vector("u8",(0,i.qC)(t)),u.object(a.H$)]}),[h]=u.moveCall({target:`${o}::vaa::verify_only_once`,arguments:[u.object(this.tokenBridgeObjectId),g]}),[f]=u.moveCall({target:`${o}::complete_transfer_with_payload::authorize_transfer`,arguments:[u.object(this.tokenBridgeObjectId),h],typeArguments:[l]}),p=await this.getPackageId();u.moveCall({target:`${p}::redeem::complete_transfer`,arguments:[u.object(this.tokenBridgeRelayerObjectId),f],typeArguments:[l]}),yield this.createUnsignedTx(u,"AutomaticTokenBridge.redeem")}async getRelayerFee(e,t){let r=(0,i.tY)(t)?u.$.nativeTokenId(this.network,this.chain):t,n=await this.getTokenInfo(r.toString());if(null===n)throw Error("Unsupported token for relay");let a=await this.getFields(),o=await this.connection.getDynamicFieldObject({parentId:this.tokenBridgeRelayerObjectId,name:{type:"vector<u8>",value:Array.from(c.aI.encode("relayer_fees"))}});if(!o.data||!o.data.content){if(o.error)throw Error("Failed to get relayer fees: "+JSON.stringify(o.error));throw Error("Unable to compute relayer fee")}let{content:s}=o.data;if(!(0,g.YV)(s)||!(0,g.D7)(s.fields.id))throw Error("Unable to compute relayer fee");let l=await this.connection.getDynamicFieldObject({parentId:s.fields.id.id,name:{type:"u16",value:(0,d.Vn)(e)}});if(!l.data||!l.data.content){if(l.error)throw Error("Failed to get relayer fees: "+JSON.stringify(o.error));throw Error("Unable to compute relayer fee")}let{content:h}=l.data;if(!(0,g.YV)(h))throw Error("Unable to compute relayer fee");let f=await u.$.getDecimals(this.network,this.chain,this.connection,t.toString()),p=n.swap_rate,m=a.relayer_fee_precision,w=a.swap_rate_precision,y=h.fields.value;return 10n**BigInt(f)*BigInt(y)*BigInt(w)/(BigInt(p)*BigInt(m))}async maxSwapAmount(e){let t=((0,i.tY)(e)?u.$.nativeTokenId(this.network,this.chain):e).toString(),r=await this.connection.getCoinMetadata({coinType:t});if(!r)throw Error("metadata is null");let a=await this.getPackageId(),o=new n.Y;o.moveCall({target:`${a}::redeem::calculate_max_swap_amount_in`,arguments:[o.object(this.tokenBridgeRelayerObjectId),o.pure.u8(r.decimals)],typeArguments:[t]});let s=await this.connection.devInspectTransactionBlock({transactionBlock:o,sender:c.$v.encode(new Uint8Array(32))});if(!s.results||0==s.results.length||!s.results[0]?.returnValues||s.results[0]?.returnValues.length!==1)throw Error("swap rate not set");return c.Al.decode(new Uint8Array(s.results[0].returnValues[0][0].toReversed()))}async nativeTokenAmount(e,t){let r=((0,i.tY)(e)?u.$.nativeTokenId(this.network,this.chain):e).toString(),a=await this.connection.getCoinMetadata({coinType:r});if(!a)throw Error("metadata is null");let o=await this.getPackageId(),s=new n.Y;s.moveCall({target:`${o}::redeem::calculate_native_swap_amount_out`,arguments:[s.object(this.tokenBridgeRelayerObjectId),s.pure.u64(t),s.pure.u8(a.decimals)],typeArguments:[r]});let d=await this.connection.devInspectTransactionBlock({transactionBlock:s,sender:c.$v.encode(new Uint8Array(32))});if(!d.results||0==d.results.length||!d.results[0]?.returnValues||d.results[0]?.returnValues.length!==1)throw Error("swap rate not set");return c.Al.decode(new Uint8Array(d.results[0].returnValues[0][0].toReversed()))}async getRegisteredTokens(){let e=(await this.getFields()).registered_tokens.fields.id.id;return(await this.connection.getDynamicFields({parentId:e})).data.map(e=>{let{address:t,module:r,name:i}=(0,o.$A)(e.objectType);return new l.Ne([t,r,i].join(y.M))})}async isRegisteredToken(e){let t=new l.Ne((0,i.tY)(e)?u.$.nativeTokenId(this.network,this.chain).address:e).unwrap();try{return await this.getTokenInfo(t)!==null}catch(e){console.error(e)}return!1}async getTokenInfo(e){let t=await this.getFields(),r=new l.Ne(t.registered_tokens.type).getPackageId(),i=t.registered_tokens.fields.id.id,n=new l.Ne(e),a=(0,g.Y4)(y.Z,n.unwrap())?y.Z:n.getCoinType();try{let e=await this.connection.getDynamicFieldObject({parentId:i,name:{type:`${r}::registered_tokens::Key<${a}>`,value:{dummy_field:!1}}});if(e.error)throw Error("Failed to get token info: "+JSON.stringify(e.error));if(!e.data||!e.data.content)throw Error("Failed to get token info: "+JSON.stringify(e));let{content:t}=e.data;if((0,g.YV)(t)&&(0,g.YV)(t.fields.value))return t.fields.value.fields;return null}catch(e){if(e?.code===-32e3&&e.message?.includes("RPC Error"))return console.error(e),null;throw e}}async getFields(){if(!this.fields){let e=await (0,h.dC)(this.connection,this.tokenBridgeRelayerObjectId);if(null===e)throw Error("Failed to get fields from token bridge relayer state");this.fields=e}return this.fields}async getPackageId(){let e=await this.getFields();return new l.Ne(e.registered_tokens.type).getPackageId()}async getPackageIds(){let[e,t]=await Promise.all([(0,h.$6)(this.connection,this.coreBridgeObjectId),(0,h.$6)(this.connection,this.tokenBridgeObjectId)]);return{coreBridge:e,tokenBridge:t}}createUnsignedTx(e,t,r=!1){return new f.A(e,this.network,this.chain,t,r)}}(0,i.sW)("Sui","TokenBridge",w),(0,i.sW)("Sui","AutomaticTokenBridge",b)},38313:function(e,t,r){r.d(t,{A:function(){return i}});class i{transaction;network;chain;description;parallelizable;constructor(e,t,r,i,n=!1){this.transaction=e,this.network=t,this.chain=r,this.description=i,this.parallelizable=n}}}}]);