"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[260],{53260:function(e,t,r){r.r(t),r.d(t,{SuiCircleBridge:function(){return h},_suiCircleObjects:function(){return u},suiCircleObjects:function(){return m}});var s=r(79456),a=r(95351),n=r(61049),i=r(38313),o=r(26862),c=r(85570),d=r(22256);let u=[["Testnet",{tokenMessengerState:"0x5252abd1137094ed1db3e0d75bc36abcd287aee4bc310f8e047727ef5682e7c2",messageTransmitterState:"0x98234bd0fa9ac12cc0a20a144a22e36d6a32f7e0a97baaeaf9c76cdc6d122d2e",usdcTreasury:"0x7170137d4a6431bf83351ac025baf462909bffe2877d87716374fb42b9629ebe"}],["Mainnet",{tokenMessengerState:"0x45993eecc0382f37419864992c12faee2238f5cfe22b98ad3bf455baf65c8a2f",messageTransmitterState:"0xf68268c3d9b1df3215f2439400c1c4ea08ac4ef4bb7d6f3ca6a2a239e17510af",usdcTreasury:"0x57d6725e7a8b49a7b2a612f6bd66ab5f39fc95332ca48be421c3229d514a6de7"}]],m=(0,d.J)(u,[0,1]);class h{network;chain;provider;contracts;usdcId;usdcTreasuryId;tokenMessengerId;tokenMessengerStateId;messageTransmitterId;messageTransmitterStateId;constructor(e,t,r,s){if(this.network=e,this.chain=t,this.provider=r,this.contracts=s,"Devnet"===e)throw Error("CircleBridge not supported on Devnet");let a=o.UO.get(this.network,this.chain);if(!a)throw Error(`No USDC contract configured for network=${this.network} chain=${this.chain}`);let{tokenMessengerState:n,messageTransmitterState:i,usdcTreasury:c}=m(e);if(!s.cctp?.tokenMessenger)throw Error(`Circle Token Messenger contract for domain ${t} not found`);if(!s.cctp?.messageTransmitter)throw Error(`Circle Message Transmitter contract for domain ${t} not found`);this.usdcId=a,this.usdcTreasuryId=c,this.tokenMessengerId=s.cctp?.tokenMessenger,this.messageTransmitterId=s.cctp?.messageTransmitter,this.tokenMessengerStateId=n,this.messageTransmitterStateId=i}async *transfer(e,t,r){let s=new a.Y,i=o.vw.get(this.network,t.chain),[c,...d]=await n.$.getCoins(this.provider,e,this.usdcId);if(void 0===c)throw Error("No USDC in wallet");let u=s.object(c.coinObjectId);d.length>0&&s.mergeCoins(u,d.map(e=>s.object(e.coinObjectId)));let[m]=s.splitCoins(u,[r]);s.moveCall({target:`${this.tokenMessengerId}::deposit_for_burn::deposit_for_burn`,arguments:[m,s.pure.u32(i),s.pure.address(t.address.toUniversalAddress().toString()),s.object(this.tokenMessengerStateId),s.object(this.messageTransmitterStateId),s.object("0x403"),s.object(this.usdcTreasuryId)],typeArguments:[this.usdcId]}),yield this.createUnsignedTx(s,"Sui.CircleBridge.Transfer")}async isTransferCompleted(e){let t=new a.Y;t.moveCall({target:`${this.messageTransmitterId}::state::is_nonce_used`,arguments:[t.object(this.messageTransmitterStateId),t.pure.u32(e.sourceDomain),t.pure.u64(e.nonce)]});let r=await this.provider.devInspectTransactionBlock({sender:"0x0000000000000000000000000000000000000000000000000000000000000000",transactionBlock:t});try{return!!r.results[0].returnValues[0][0][0]}catch(e){return console.error(`Error reading if nonce was used: ${e}`),!1}}async *redeem(e,t,r){let n=new a.Y,[i]=n.moveCall({target:`${this.messageTransmitterId}::receive_message::receive_message`,arguments:[n.pure.vector("u8",s.iC.serialize(t)),n.pure.vector("u8",c.$v.decode(r)),n.object(this.messageTransmitterStateId)]});if(!i)throw Error("Failed to produce receipt");let[o]=n.moveCall({target:`${this.tokenMessengerId}::handle_receive_message::handle_receive_message`,arguments:[i,n.object(this.tokenMessengerStateId),n.object("0x403"),n.object(this.usdcTreasuryId)],typeArguments:[this.usdcId]});if(!o)throw Error("Failed to produce stamp receipt ticket with burn message");let[d]=n.moveCall({target:`${this.tokenMessengerId}::handle_receive_message::deconstruct_stamp_receipt_ticket_with_burn_message`,arguments:[o]});if(!d)throw Error("Failed to produce stamp receipt ticket");let[u]=n.moveCall({target:`${this.messageTransmitterId}::receive_message::stamp_receipt`,arguments:[d,n.object(this.messageTransmitterStateId)],typeArguments:[`${this.tokenMessengerId}::message_transmitter_authenticator::MessageTransmitterAuthenticator`]});if(!u)throw Error("Failed to produce stamped receipt");n.moveCall({target:`${this.messageTransmitterId}::receive_message::complete_receive_message`,arguments:[u,n.object(this.messageTransmitterStateId)]}),yield this.createUnsignedTx(n,"Sui.CircleBridge.Redeem")}async parseTransactionDetails(e){let t=await this.provider.waitForTransaction({digest:e,options:{showEvents:!0,showEffects:!0,showInput:!0}});if(!t)throw Error("Transaction not found");if(!t.events)throw Error("Transaction events not found");let r=t.events?.find(e=>e.type.includes("send_message::MessageSent"));if(!r)throw Error("No MessageSent event found");let a=new Uint8Array((r?.parsedJson).message),[n,i]=s.iC.deserialize(a),{payload:c}=n,d=c.messageSender,u=c.mintRecipient,m=o.yN(this.network,n.sourceDomain),h=o.yN(this.network,n.destinationDomain),g={chain:m,address:c.burnToken};return{from:{chain:m,address:d},to:{chain:h,address:u},token:g,amount:c.amount,message:n,id:{hash:i}}}static async fromRpc(e,t){let[r,s]=await n.$.chainFromRpc(e),a=t[s];if(a.network!==r)throw Error(`Network mismatch: ${a.network} != ${r}`);return new h(r,s,e,a.contracts)}createUnsignedTx(e,t,r=!1){return new i.A(e,this.network,this.chain,t,r)}}(0,s.sW)("Sui","CircleBridge",h)},38313:function(e,t,r){r.d(t,{A:function(){return s}});class s{transaction;network;chain;description;parallelizable;constructor(e,t,r,s,a=!1){this.transaction=e,this.network=t,this.chain=r,this.description=s,this.parallelizable=a}}}}]);