import{a as w}from"./chunk-CPFQUFVD.mjs";import{a as g}from"./chunk-YLUULY6G.mjs";import{a as S}from"./chunk-HYJQHVDZ.mjs";import{a as P}from"./chunk-ILUFGYLO.mjs";import{a as m,b as f}from"./chunk-WHVCUVZP.mjs";import{a as d}from"./chunk-MAWGZICD.mjs";import{a as I}from"./chunk-5H5D6QVX.mjs";import{b as k}from"./chunk-QUJM5W4L.mjs";import{b}from"./chunk-JNNFNYDO.mjs";import{n as F,r as K}from"./chunk-HVIF6DW6.mjs";import{c as p}from"./chunk-7OUPEQRN.mjs";import{a as v}from"./chunk-ZD2TY5N3.mjs";import{b as U}from"./chunk-LQOSHBB7.mjs";import{b as H}from"./chunk-RXHER6EA.mjs";import{b as A}from"./chunk-VHY6ZATX.mjs";function D(n,s){if(s.serializeStr(n.jwt),s.serializeStr(n.uidKey),s.serializeFixedBytes(n.pepper),n.ephemeralKeyPair.serialize(s),n.proof===void 0)throw new Error("Cannot serialize - proof undefined");n.proof.serialize(s),s.serializeOption(n.verificationKeyHash,32)}function B(n){let s=n.deserializeStr(),h=n.deserializeStr(),u=n.deserializeFixedBytes(31),x=I.deserialize(n),z=F.deserialize(n),E=n.deserializeOption("fixedBytes",32);return{jwt:s,uidKey:h,pepper:u,ephemeralKeyPair:x,proof:z,verificationKeyHash:E}}var M;($=>{function n(e){let t=new H;switch(t.serializeU32AsUleb128(e.signingScheme),e.accountAddress.serialize(t),e.signingScheme){case 0:return e.privateKey.serialize(t),t.toUint8Array();case 2:{if(!m(e))throw new Error("Account is not a SingleKeySigner");let o=e.getAnyPublicKey();switch(t.serializeU32AsUleb128(o.variant),o.variant){case 3:return D(e,t),t.toUint8Array();case 4:{let r=e;return D(r,t),r.publicKey.jwkAddress.serialize(t),t.serializeBool(r.audless),t.toUint8Array()}case 1:case 0:return e.privateKey.serialize(t),t.toUint8Array();default:throw new Error(`Invalid public key variant: ${o.variant}`)}}case 3:{let o=e;return o.publicKey.serialize(t),t.serializeU32AsUleb128(o.signers.length),o.signers.forEach(r=>{t.serializeFixedBytes(n(r))}),t.toUint8Array()}default:throw new Error(`Deserialization of Account failed: invalid signingScheme value ${e.signingScheme}`)}}$.toBytes=n;function s(e){return A.hexInputToStringWithoutPrefix(n(e))}$.toHexStringWithoutPrefix=s;function h(e){return A.hexInputToString(n(e))}$.toHexString=h;function u(e){let{address:t,signingScheme:o}=P(e);switch(o){case 0:{let r=p.deserialize(e);return new d({privateKey:r,address:t})}case 2:{let r=e.deserializeUleb128AsU32();switch(r){case 0:{let i=p.deserialize(e);return new f({privateKey:i,address:t})}case 1:{let i=b.deserialize(e);return new f({privateKey:i,address:t})}case 3:{let i=B(e),a=K(i);return new g({...i,...a})}case 4:{let i=B(e),a=U.deserialize(e),y=e.deserializeBool(),l=K(i);return new w({...i,...l,jwkAddress:a,audless:y})}default:throw new Error(`Unsupported public key variant ${r}`)}}case 3:{let r=k.deserialize(e),i=e.deserializeUleb128AsU32(),a=new Array;for(let y=0;y<i;y+=1){let l=u(e);if(!m(l)&&!(l instanceof d))throw new Error("Deserialization of MultiKeyAccount failed. Signer is not a SingleKeySigner or Ed25519Account");a.push(l)}return new S({multiKey:r,signers:a,address:t})}default:throw new Error(`Deserialization of Account failed: invalid signingScheme value ${o}`)}}$.deserialize=u;function x(e){let t=c(e);if(!(t instanceof g))throw new Error("Deserialization of KeylessAccount failed");return t}$.keylessAccountFromHex=x;function z(e){let t=c(e);if(!(t instanceof w))throw new Error("Deserialization of FederatedKeylessAccount failed");return t}$.federatedKeylessAccountFromHex=z;function E(e){let t=c(e);if(!(t instanceof S))throw new Error("Deserialization of MultiKeyAccount failed");return t}$.multiKeyAccountFromHex=E;function j(e){let t=c(e);if(!(t instanceof f))throw new Error("Deserialization of SingleKeyAccount failed");return t}$.singleKeyAccountFromHex=j;function C(e){let t=c(e);if(!(t instanceof d))throw new Error("Deserialization of Ed25519Account failed");return t}$.ed25519AccountFromHex=C;function c(e){return u(v.fromHex(e))}$.fromHex=c;function O(e){return c(e)}$.fromBytes=O})(M||(M={}));export{M as a};
//# sourceMappingURL=chunk-W4SMZ6IW.mjs.map