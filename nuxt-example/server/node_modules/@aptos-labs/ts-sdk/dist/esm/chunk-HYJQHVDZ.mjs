import{b as g}from"./chunk-CPAAEEF4.mjs";import{b as m}from"./chunk-WHVCUVZP.mjs";import{a as p}from"./chunk-MAWGZICD.mjs";import{e as a}from"./chunk-BPHCRTHD.mjs";import{b as d,c as u}from"./chunk-QUJM5W4L.mjs";import{b as y}from"./chunk-LQOSHBB7.mjs";var A=class l{constructor(e){this.signingScheme=3;let{multiKey:i,address:s}=e,n=e.signers.map(t=>t instanceof p?m.fromEd25519Account(t):t);if(i.signaturesRequired>n.length)throw new Error(`Not enough signers provided to satisfy the required signatures. Need ${i.signaturesRequired} signers, but only ${n.length} provided`);if(i.signaturesRequired<n.length)throw new Error(`More signers provided than required. Need ${i.signaturesRequired} signers, but ${n.length} provided`);this.publicKey=i,this.accountAddress=s?y.from(s):this.publicKey.authKey().derivedAddress();let r=[];for(let t of n)r.push(this.publicKey.getIndex(t.getAnyPublicKey()));let o=n.map((t,c)=>[t,r[c]]);o.sort((t,c)=>t[1]-c[1]),this.signers=o.map(t=>t[0]),this.signerIndicies=o.map(t=>t[1]),this.signaturesBitmap=this.publicKey.createBitmap({bits:r})}static fromPublicKeysAndSigners(e){let{publicKeys:i,signaturesRequired:s,signers:n}=e,r=new d({publicKeys:i,signaturesRequired:s});return new l({multiKey:r,signers:n})}static isMultiKeySigner(e){return e instanceof l}signWithAuthenticator(e){return new a(this.publicKey,this.sign(e))}signTransactionWithAuthenticator(e){return new a(this.publicKey,this.signTransaction(e))}async waitForProofFetch(){let i=this.signers.filter(s=>s instanceof g).map(async s=>s.waitForProofFetch());await Promise.all(i)}async checkKeylessAccountValidity(e){let s=this.signers.filter(n=>n instanceof g).map(n=>n.checkKeylessAccountValidity(e));await Promise.all(s)}sign(e){let i=[];for(let s of this.signers)i.push(s.sign(e));return new u({signatures:i,bitmap:this.signaturesBitmap})}signTransaction(e){let i=[];for(let s of this.signers)i.push(s.signTransaction(e));return new u({signatures:i,bitmap:this.signaturesBitmap})}verifySignature(e){let{message:i,signature:s}=e;if(!this.signerIndicies.every((r,o)=>o===0||r>=this.signerIndicies[o-1]))return!1;for(let r=0;r<s.signatures.length;r+=1){let o=s.signatures[r];if(!this.publicKey.publicKeys[this.signerIndicies[r]].verifySignature({message:i,signature:o}))return!1}return!0}};export{A as a};
//# sourceMappingURL=chunk-HYJQHVDZ.mjs.map