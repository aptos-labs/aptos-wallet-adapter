import{b as y,c as f,d as x,e as v,f as A,g as C,h as U,i as b,j as I,k as M,l as P,m as E,n as G,o as N}from"./chunk-5W2ERBGY.mjs";import{a as l}from"./chunk-PDAWVDI7.mjs";import{b as w}from"./chunk-LQOSHBB7.mjs";function V(e){return!!e.match(/^[_a-zA-Z0-9]+$/)}function W(e){return!!e.match(/\s/)}function $(e){return!!e.match(/^T[0-9]+$/)}function F(e){return!!e.match(/^&.+$/)}function k(e){switch(e){case"signer":case"address":case"bool":case"u8":case"u16":case"u32":case"u64":case"u128":case"u256":return!0;default:return!1}}function L(e,i){let c=i;for(;c<e.length;c+=1){let s=e[c];if(!W(s))break}return c}var R=(a=>(a.InvalidTypeTag="unknown type",a.UnexpectedGenericType="unexpected generic type",a.UnexpectedTypeArgumentClose="unexpected '>'",a.UnexpectedWhitespaceCharacter="unexpected whitespace character",a.UnexpectedComma="unexpected ','",a.TypeArgumentCountMismatch="type argument count doesn't match expected amount",a.MissingTypeArgumentClose="no matching '>' for '<'",a.MissingTypeArgument="no type argument before ','",a.UnexpectedPrimitiveTypeArguments="primitive types not expected to have type arguments",a.UnexpectedVectorTypeArgumentCount="vector type expected to have exactly one type argument",a.UnexpectedStructFormat="unexpected struct format, must be of the form 0xaddress::module_name::struct_name",a.InvalidModuleNameCharacter="module name must only contain alphanumeric or '_' characters",a.InvalidStructNameCharacter="struct name must only contain alphanumeric or '_' characters",a.InvalidAddress="struct address must be valid",a))(R||{}),t=class extends Error{constructor(i,c){super(`Failed to parse typeTag '${i}', ${c}`)}};function j(e,i){let c=i?.allowGenerics??!1,s=[],u=[],n=[],o=0,r="",T=1;for(;o<e.length;){let d=e[o];if(d==="<")s.push({savedExpectedTypes:T,savedStr:r,savedTypes:n}),r="",n=[],T=1;else if(d===">"){if(r!==""){let a=g(r,u,c);n.push(a)}let p=s.pop();if(p===void 0)throw new t(e,"unexpected '>'");if(T!==n.length)throw new t(e,"type argument count doesn't match expected amount");let{savedStr:m,savedTypes:h,savedExpectedTypes:_}=p;u=n,n=h,r=m,T=_}else if(d===","){if(s.length===0)throw new t(e,"unexpected ','");if(r.length===0)throw new t(e,"no type argument before ','");let p=g(r,u,c);u=[],n.push(p),r="",T+=1}else if(W(d)){let p=!1;if(r.length!==0){let h=g(r,u,c);u=[],n.push(h),r="",p=!0}o=L(e,o);let m=e[o];if(o<e.length&&p&&m!==","&&m!==">")throw new t(e,"unexpected whitespace character");continue}else r+=d;o+=1}if(s.length>0)throw new t(e,"no matching '>' for '<'");switch(n.length){case 0:return g(r,u,c);case 1:if(r==="")return n[0];throw new t(e,"unexpected ','");default:throw new t(e,"unexpected whitespace character")}}function g(e,i,c){let s=e.trim(),u=s.toLowerCase();if(k(u)&&i.length>0)throw new t(e,"primitive types not expected to have type arguments");switch(s.toLowerCase()){case"signer":return new I;case"bool":return new y;case"address":return new b;case"u8":return new f;case"u16":return new x;case"u32":return new v;case"u64":return new A;case"u128":return new C;case"u256":return new U;case"vector":if(i.length!==1)throw new t(e,"vector type expected to have exactly one type argument");return new E(i[0]);default:if(F(s)){let r=s.substring(1);return new M(g(r,i,c))}if($(s)){if(c)return new P(Number(s.split("T")[1]));throw new t(e,"unexpected generic type")}if(!s.match(/:/))throw new t(e,"unknown type");let n=s.split("::");if(n.length!==3)throw new t(e,"unexpected struct format, must be of the form 0xaddress::module_name::struct_name");let o;try{o=w.fromString(n[0])}catch{throw new t(e,"struct address must be valid")}if(!V(n[1]))throw new t(e,"module name must only contain alphanumeric or '_' characters");if(!V(n[2]))throw new t(e,"struct name must only contain alphanumeric or '_' characters");return new G(new N(o,new l(n[1]),new l(n[2]),i))}}export{R as a,t as b,j as c};
//# sourceMappingURL=chunk-GI4AR6DQ.mjs.map