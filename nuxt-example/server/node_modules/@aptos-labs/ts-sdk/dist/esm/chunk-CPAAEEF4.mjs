import{a as O,b as _}from"./chunk-P5CM4C2G.mjs";import{d as A}from"./chunk-BPHCRTHD.mjs";import{a as R}from"./chunk-5H5D6QVX.mjs";import{a as u,b as w}from"./chunk-2TRQERBL.mjs";import{a as I}from"./chunk-XW3BXTCZ.mjs";import{i as b,j as T,k as x,n as P,q as v,s as k}from"./chunk-HVIF6DW6.mjs";import{d as r}from"./chunk-TH5JCPN2.mjs";import{e as F}from"./chunk-BHVSIRNF.mjs";import{b as g}from"./chunk-LQOSHBB7.mjs";import{a as m}from"./chunk-RXHER6EA.mjs";import{b as y}from"./chunk-VHY6ZATX.mjs";import D from"eventemitter3";import{jwtDecode as W}from"jwt-decode";function ne(f){return f!=null&&typeof f.checkKeylessAccountValidity=="function"}var p=class p extends m{constructor(e){super();this.signingScheme=2;let{address:i,ephemeralKeyPair:t,publicKey:o,uidKey:l,uidVal:n,aud:c,pepper:s,proof:a,proofFetchCallback:h,jwt:d,verificationKeyHash:K}=e;if(this.ephemeralKeyPair=t,this.publicKey=o,this.accountAddress=i?g.from(i):this.publicKey.authKey().derivedAddress(),this.uidKey=l,this.uidVal=n,this.aud=c,this.jwt=d,this.emitter=new D,this.proofOrPromise=a,a instanceof P)this.proof=a;else{if(h===void 0)throw new Error("Must provide callback for async proof fetch");this.emitter.on("proofFetchFinish",async C=>{await h(C),this.emitter.removeAllListeners()}),this.init(a)}let S=y.fromHexInput(s).toUint8Array();if(S.length!==p.PEPPER_LENGTH)throw new Error(`Pepper length in bytes should be ${p.PEPPER_LENGTH}`);if(this.pepper=S,K!==void 0){if(y.hexInputToUint8Array(K).length!==32)throw new Error("verificationKeyHash must be 32 bytes");this.verificationKeyHash=y.hexInputToUint8Array(K)}}getAnyPublicKey(){return new u(this.publicKey)}async init(e){try{this.proof=await e,this.emitter.emit("proofFetchFinish",{status:"Success"})}catch(i){i instanceof Error?this.emitter.emit("proofFetchFinish",{status:"Failed",error:i.toString()}):this.emitter.emit("proofFetchFinish",{status:"Failed",error:"Unknown"})}}serialize(e){if(this.accountAddress.serialize(e),e.serializeStr(this.jwt),e.serializeStr(this.uidKey),e.serializeFixedBytes(this.pepper),this.ephemeralKeyPair.serialize(e),this.proof===void 0)throw new Error("Cannot serialize - proof undefined");this.proof.serialize(e),e.serializeOption(this.verificationKeyHash,32)}static partialDeserialize(e){let i=g.deserialize(e),t=e.deserializeStr(),o=e.deserializeStr(),l=e.deserializeFixedBytes(31),n=R.deserialize(e),c=P.deserialize(e),s=e.deserializeOption("fixedBytes",32);return{address:i,jwt:t,uidKey:o,pepper:l,ephemeralKeyPair:n,proof:c,verificationKeyHash:s}}isExpired(){return this.ephemeralKeyPair.isExpired()}signWithAuthenticator(e){let i=new w(this.sign(e)),t=new u(this.publicKey);return new A(t,i)}signTransactionWithAuthenticator(e){let i=new w(this.signTransaction(e)),t=new u(this.publicKey);return new A(t,i)}async waitForProofFetch(){this.proofOrPromise instanceof Promise&&await this.proofOrPromise}async checkKeylessAccountValidity(e){if(this.isExpired())throw r.fromErrorType({type:0});if(await this.waitForProofFetch(),this.proof===void 0)throw r.fromErrorType({type:2});let i=W(this.jwt,{header:!0});if(i.kid===void 0)throw r.fromErrorType({type:12,details:"checkKeylessAccountValidity failed. JWT is missing 'kid' in header. This should never happen."});if(this.verificationKeyHash!==void 0){let{verificationKey:t}=await v({aptosConfig:e});if(y.hexInputToString(t.hash())!==y.hexInputToString(this.verificationKeyHash))throw r.fromErrorType({type:4})}else console.warn("[Aptos SDK] The verification key hash was not set. Proof may be invalid if the verification key has rotated.");await p.fetchJWK({aptosConfig:e,publicKey:this.publicKey,kid:i.kid})}sign(e){let{expiryDateSecs:i}=this.ephemeralKeyPair;if(this.isExpired())throw r.fromErrorType({type:0});if(this.proof===void 0)throw r.fromErrorType({type:1,details:"Proof not found - make sure to call `await account.checkKeylessAccountValidity()` before signing."});let t=this.ephemeralKeyPair.getPublicKey(),o=this.ephemeralKeyPair.sign(e);return new T({jwtHeader:F(this.jwt.split(".")[0]),ephemeralCertificate:new x(this.proof,0),expiryDateSecs:i,ephemeralPublicKey:t,ephemeralSignature:o})}signTransaction(e){if(this.proof===void 0)throw r.fromErrorType({type:1,details:"Proof not found - make sure to call `await account.checkKeylessAccountValidity()` before signing."});let i=O(e),o=new E(i,this.proof.proof).hash();return this.sign(o)}verifySignature(e){let{message:i,signature:t}=e;return!(this.isExpired()||!this.ephemeralKeyPair.getPublicKey().verifySignature({message:i,signature:t.ephemeralSignature}))}static async fetchJWK(e){let{aptosConfig:i,publicKey:t,kid:o}=e,l=t instanceof b?t:t.keylessPublicKey,{iss:n}=l,c,s=t instanceof I?t.jwkAddress:void 0;try{c=await k({aptosConfig:i,jwkAddr:s})}catch(d){throw r.fromErrorType({type:24,error:d,details:`Failed to fetch ${s?"Federated":"Patched"}JWKs ${s?`for address ${s}`:"0x1"}`})}let a=c.get(n);if(a===void 0)throw r.fromErrorType({type:7,details:`JWKs for issuer ${n} not found.`});let h=a.find(d=>d.kid===o);if(h===void 0)throw r.fromErrorType({type:6,details:`JWK with kid '${o}' for issuer '${n}' not found.`});return h}};p.PEPPER_LENGTH=31;var H=p,E=class extends m{constructor(e,i){super();this.domainSeparator="APTOS::TransactionAndProof";this.transaction=e,this.proof=i}serialize(e){e.serializeFixedBytes(this.transaction.bcsToBytes()),e.serializeOption(this.proof)}hash(){return _(this.bcsToBytes(),this.domainSeparator)}};export{ne as a,H as b,E as c};
//# sourceMappingURL=chunk-CPAAEEF4.mjs.map